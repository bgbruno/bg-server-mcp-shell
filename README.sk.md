# MCP server pre shell

üåç **Jazyky:** [English](README.md) | [Slovenƒçina](README.sk.md)

---

MCP server na sp√∫≈°tanie **dlhodobo be≈æiacich procesov v PTY (pseudo-termin√°l)** s real-time streamovan√≠m v√Ωstupu.

## Kƒæ√∫ƒçov√© vlastnosti

- ‚úÖ **Real-time output streaming** - v√Ωstup sa streamuje live do termin√°lu
- ‚úÖ **Interakt√≠vne procesy** - mo≈ænos≈• posiela≈• vstup do be≈æiaceho procesu
- ‚úÖ **Multiple sessions** - spusti≈• a kontrolova≈• viacer√© procesy s√∫ƒçasne
- ‚úÖ **Buffered output** - cel√Ω v√Ωstup sa uchov√°va a m√¥≈æe≈° ho ƒç√≠ta≈• opakovane
- ‚úÖ **PTY emulation** - proces be≈æ√≠ ako v skutoƒçnom termin√°li

## Dostupn√© n√°stroje

### 1. `startProcess`
Spust√≠ dlhodobo be≈æiaci proces v PTY termin√°le.

**Parametre:**
```javascript
{
  cmd: string,              // pr√≠kaz na spustenie
  args: string[],           // pole argumentov
  cwd: string,              // pracovn√Ω adres√°r
  env?: object,             // environment premenn√© (optional)
  rows?: number,            // v√Ω≈°ka termin√°lov√©ho okna (optional)
  cols?: number,            // ≈°√≠rka termin√°lov√©ho okna (optional)
  shellOnWindows?: boolean  // pou≈æi≈• shell na Windows (optional)
}
```

**V√Ωstup:**
```javascript
{
  ok: boolean,
  sessionId: string,  // unique ID pre t√∫to session
  pid: number         // process ID v syst√©me
}
```

**Pr√≠klad:**
```javascript
const result = await startProcess({
  cmd: "npm",
  args: ["run", "dev"],
  cwd: "/Users/bgbruno/project"
});
// ‚Üí { ok: true, sessionId: "abc-123", pid: 12345 }
```

---

### 2. `getSessionOutput`
Preƒç√≠ta buffered v√Ωstup z be≈æiacej alebo ukonƒçenej PTY session.

**Parametre:**
```javascript
{
  sessionId: string,  // ID session z startProcess
  fromIndex?: number  // od ktor√©ho riadku ƒç√≠ta≈• (default: 0)
}
```

**V√Ωstup:**
```javascript
{
  ok: boolean,
  sessionId: string,
  isRunning: boolean,      // ƒçi proces st√°le be≈æ√≠
  exitCode: number | null, // exit k√≥d (ak skonƒçil)
  exitSignal: number | null,
  output: [                // pole v√Ωstupov
    {
      type: "stdout" | "stderr",
      data: string,        // text v√Ωstupu
      timestamp: string    // ISO timestamp
    }
  ],
  totalLines: number       // celkov√Ω poƒçet riadkov
}
```

**Pr√≠klad:**
```javascript
const output = await getSessionOutput({
  sessionId: "abc-123",
  fromIndex: 0
});

// ƒå√≠ta≈• len nov√© riadky (od posledn√©ho volania)
const newOutput = await getSessionOutput({
  sessionId: "abc-123",
  fromIndex: output.totalLines
});
```

---

### 3. `writeInput`
Po≈°le vstup do be≈æiacej PTY session (simuluje p√≠sanie do termin√°lu).

**Parametre:**
```javascript
{
  sessionId: string,  // ID session
  data: string        // text na odoslanie (napr. "rs\n")
}
```

**V√Ωstup:**
```javascript
{
  ok: boolean
}
```

**Pr√≠klad:**
```javascript
// Re≈°tartova≈• Vite dev server
await writeInput({
  sessionId: "abc-123",
  data: "rs\n"
});

// Potvrdi≈• yes
await writeInput({
  sessionId: "abc-123",
  data: "y\n"
});

// Ukonƒçi≈• proces
await writeInput({
  sessionId: "abc-123",
  data: "q\n"
});
```

---

### 4. `stopProcess`
Zastav√≠ be≈æiacu PTY session.

**Parametre:**
```javascript
{
  sessionId: string  // ID session na zastavenie
}
```

**V√Ωstup:**
```javascript
{
  ok: boolean,
  killed: boolean  // ƒçi bol proces zabit√Ω
}
```

**Pr√≠klad:**
```javascript
await stopProcess({
  sessionId: "abc-123"
});
```

---

### 5. `listSessions`
Vyp√≠≈°e v≈°etky akt√≠vne PTY sessions.

**Parametre:**
```javascript
{}  // ≈æiadne parametre
```

**Pr√≠klad:**
```javascript
const sessions = await listSessions();
// ‚Üí zoznam v≈°etk√Ωch akt√≠vnych sessions
```

---

### 6. `cleanupSessions`
Odstr√°ni ukonƒçen√© (non-running) sessions z pam√§te.

**Parametre:**
```javascript
{
  sessionId?: string  // optional - vyƒçisti≈• konkr√©tnu session
}
```

**Pr√≠klad:**
```javascript
// Vyƒçisti≈• konkr√©tnu session
await cleanupSessions({ sessionId: "abc-123" });

// Vyƒçisti≈• v≈°etky ukonƒçen√© sessions
await cleanupSessions({});
```

---

## Typick√Ω workflow

### Z√°kladn√© pou≈æitie

```javascript
// 1. Spusti≈• proces
const { sessionId, pid } = await startProcess({
  cmd: "npm",
  args: ["run", "dev"],
  cwd: "/project/path"
});

console.log(`Started process ${pid} with session ${sessionId}`);

// 2. Poƒçka≈• na inicializ√°ciu
await new Promise(resolve => setTimeout(resolve, 2000));

// 3. Preƒç√≠ta≈• v√Ωstup
const output = await getSessionOutput({ 
  sessionId,
  fromIndex: 0 
});

console.log(`Process is ${output.isRunning ? 'running' : 'stopped'}`);
console.log('Output:', output.output.map(o => o.data).join(''));

// 4. Posla≈• input (ak treba)
await writeInput({ 
  sessionId, 
  data: "rs\n" 
});

// 5. Preƒç√≠ta≈• nov√Ω v√Ωstup
const newOutput = await getSessionOutput({ 
  sessionId,
  fromIndex: output.totalLines 
});

// 6. Zastavi≈• proces
await stopProcess({ sessionId });
```

---

### Multiple paraleln√© procesy

```javascript
// Spusti≈• 3 procesy naraz
const sessions = {
  frontend: await startProcess({
    cmd: "npm", args: ["run", "dev"],
    cwd: "/project/frontend"
  }),
  backend: await startProcess({
    cmd: "node", args: ["server.js"],
    cwd: "/project/backend"
  }),
  tests: await startProcess({
    cmd: "npm", args: ["run", "test:watch"],
    cwd: "/project/tests"
  })
};

// Kontrolova≈• ka≈æd√Ω proces zvl√°≈°≈•
for (const [name, session] of Object.entries(sessions)) {
  const output = await getSessionOutput({
    sessionId: session.sessionId,
    fromIndex: 0
  });
  console.log(`${name}: ${output.isRunning ? 'running ‚úÖ' : 'stopped ‚ùå'}`);
}

// Posla≈• input do konkr√©tneho procesu
await writeInput({ 
  sessionId: sessions.tests.sessionId,
  data: "a\n"  // run all tests
});

// Zastavi≈• konkr√©tny proces
await stopProcess({ 
  sessionId: sessions.frontend.sessionId 
});

// Zastavi≈• v≈°etky
for (const session of Object.values(sessions)) {
  await stopProcess({ sessionId: session.sessionId });
}
```

---

## Kedy pou≈æi≈• shell-bg?

| Situ√°cia | Pou≈æi≈• shell-bg? |
|----------|------------------|
| Dev server (npm run dev, vite, webpack) | ‚úÖ √Åno |
| Watch m√≥dy (nodemon, jest --watch) | ‚úÖ √Åno |
| Long-running procesy (docker-compose up) | ‚úÖ √Åno |
| Interakt√≠vne CLI (npm init, git commit) | ‚úÖ √Åno |
| Kr√°tke pr√≠kazy (ls, cat, grep) | ‚ùå Nie (pou≈æi≈• mcp8_shell_execute) |
| Jednor√°zov√© pr√≠kazy s r√Ωchlym v√Ωstupom | ‚ùå Nie (pou≈æi≈• mcp8_shell_execute) |

---

## Porovnanie s in√Ωmi shell n√°strojmi

| N√°stroj | Dlhodob√© procesy | V√Ωstup v response | Interakcia | Pou≈æitie |
|---------|------------------|-------------------|------------|----------|
| **mcp6 (shell-bg)** | ‚úÖ √Åno | ‚úÖ Buffer + terminal | ‚úÖ writeInput | Dev servery, watch m√≥dy |
| **mcp8 (shell-tumf)** | ‚ùå Zasekne sa | ‚úÖ √Åno | ‚ùå Nie | ls, cat, grep, git status |
| **mcp7 (shell-hdresearch)** | ‚ùå Zasekne sa | ‚úÖ √Åno | ‚ùå Nie | Z√°kladn√© pr√≠kazy |
| **run_command** | ‚ö†Ô∏è Blocking/Async | ‚ö†Ô∏è ƒåiastoƒçne | ‚ùå Nie | ≈†tandardn√© pr√≠kazy s user schv√°len√≠m |

---

## Pr√≠klady pou≈æitia

### Dev server debugging

```javascript
// Spusti≈• Vite
const { sessionId } = await startProcess({
  cmd: "npm",
  args: ["run", "dev"],
  cwd: "/project"
});

// Poƒçka≈• 2s
await new Promise(r => setTimeout(r, 2000));

// Preƒç√≠ta≈• output a hƒæada≈• error
const output = await getSessionOutput({ sessionId });
const hasError = output.output.some(o => 
  o.data.includes('error') || o.data.includes('Error')
);

if (hasError) {
  console.log('‚ùå Dev server m√° chybu!');
  // V√Ωpis error logu
  output.output
    .filter(o => o.type === 'stderr')
    .forEach(o => console.error(o.data));
}

// Re≈°tart servera
await writeInput({ sessionId, data: "rs\n" });

// Zastavi≈•
await stopProcess({ sessionId });
```

---

### Docker Compose management

```javascript
// Spusti≈• docker-compose
const { sessionId } = await startProcess({
  cmd: "docker-compose",
  args: ["up"],
  cwd: "/project/docker"
});

// Sledova≈• logy
const checkLogs = async () => {
  const output = await getSessionOutput({ 
    sessionId,
    fromIndex: 0 
  });
  
  const isReady = output.output.some(o => 
    o.data.includes('database system is ready')
  );
  
  return isReady;
};

// Poƒçka≈• k√Ωm DB nie je ready
while (!(await checkLogs())) {
  await new Promise(r => setTimeout(r, 1000));
}

console.log('‚úÖ Docker Compose is ready!');

// Zastavi≈• (Ctrl+C)
await writeInput({ sessionId, data: "\x03" });
```

---

## Tipy & Triky

### 1. **Inkrement√°lne ƒç√≠tanie v√Ωstupu**
```javascript
let lastIndex = 0;

setInterval(async () => {
  const output = await getSessionOutput({ 
    sessionId,
    fromIndex: lastIndex 
  });
  
  // Len nov√© riadky
  output.output.forEach(o => console.log(o.data));
  
  lastIndex = output.totalLines;
}, 1000);
```

### 2. **Graceful shutdown**
```javascript
// Pok√∫si≈• sa ukonƒçi≈• "nice"
await writeInput({ sessionId, data: "q\n" });
await new Promise(r => setTimeout(r, 1000));

// Force kill ak st√°le be≈æ√≠
const status = await getSessionOutput({ sessionId });
if (status.isRunning) {
  await stopProcess({ sessionId });
}
```

### 3. **Timeout pre startup**
```javascript
const waitForReady = async (sessionId, timeout = 10000) => {
  const start = Date.now();
  
  while (Date.now() - start < timeout) {
    const output = await getSessionOutput({ sessionId });
    const ready = output.output.some(o => o.data.includes('ready'));
    
    if (ready) return true;
    if (!output.isRunning) throw new Error('Process died');
    
    await new Promise(r => setTimeout(r, 500));
  }
  
  throw new Error('Timeout waiting for ready');
};

const { sessionId } = await startProcess({...});
await waitForReady(sessionId);
console.log('‚úÖ Process is ready!');
```

---

## Troubleshooting

### Proces sa hneƒè ukonƒç√≠
```javascript
const output = await getSessionOutput({ sessionId });
console.log('Exit code:', output.exitCode);
console.log('Output:', output.output.map(o => o.data).join(''));
// ‚Üí skontroluj error v v√Ωstupe
```

### V√Ωstup je pr√°zdny
```javascript
// Poƒçkaj chv√≠ƒæu, output m√¥≈æe trva≈•
await new Promise(r => setTimeout(r, 2000));
const output = await getSessionOutput({ sessionId });
```

### Session not found
```javascript
// Session bola vyƒçisten√° - kontroluj listSessions
const sessions = await listSessions();
console.log('Active sessions:', sessions);
```

---

## Best Practices

1. ‚úÖ **V≈ædy ukladaj sessionId** - potrebuje≈° ho pre v≈°etky oper√°cie
2. ‚úÖ **Kontroluj isRunning** - pred writeInput skontroluj ƒçi proces be≈æ√≠
3. ‚úÖ **Pou≈æ√≠vaj fromIndex** - efekt√≠vnej≈°ie ƒç√≠tanie len nov√Ωch riadkov
4. ‚úÖ **Cleanup sessions** - zavolaj stopProcess keƒè u≈æ nepotrebuje≈° proces
5. ‚úÖ **Timeout ochrana** - neƒçakaj donekoneƒçna na output
6. ‚úÖ **Error handling** - kontroluj exitCode a stderr output

---

## Z√°ver

**shell-bg je ide√°lny pre:**
- üöÄ Dev servery (Vite, webpack, Next.js)
- üîÑ Watch m√≥dy (nodemon, jest --watch)
- üê≥ Docker / Docker Compose
- üß™ Long-running tests
- üí¨ Interakt√≠vne CLI n√°stroje

**Hlavn√° v√Ωhoda:** Real-time stream + interakcia + multiple sessions = pln√° kontrola! üí™